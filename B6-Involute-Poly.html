<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Polygon Involute Construction - Optimized Namings</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      font-family: Inter, system-ui, -apple-system, sans-serif;
      background: #f7f7f7;
    }

    #drawingCanvas {
      background: #fff;
      border-radius: 0.75rem;
      border: 1px solid #e5e7eb;
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.06);
      max-width: 100%;
    }

    .step-button {
      transition: all .15s;
      cursor: pointer;
    }

    .step-button:disabled {
      opacity: .45;
      cursor: not-allowed;
    }

    .input-group {
      margin-bottom: 1rem;
    }

    .input-group label {
      display: block;
      font-weight: 500;
      margin-bottom: 0.25rem;
    }

    .input-group input {
      width: 100%;
      padding: 0.5rem;
      border: 1px solid #d1d5db;
      border-radius: 0.375rem;
    }

    .normal-color {
      color: #059669;
      font-weight: bold;
    }

    .tangent-color {
      color: #ef4444;
      font-weight: bold;
    }
  </style>
</head>

<body class="p-4 flex flex-col items-center min-h-screen">
  <div class="max-w-7xl w-full text-center mb-6">
    <h1 class="text-2xl font-bold text-gray-800">üìê Polygon Involute Construction <a href="index.html" style="
    display: inline-block;
    margin-left: 20px;
    margin-bottom: 20px;
    padding: 10px;
    margin-left: 20px;
    text-decoration: none;
    background-color: #0ec58b;
    border-radius: 5px;
    font-size: 18px;
    color: blue;
    font-weight: 500;">Back to Home</a></h1>
  </div>

  <div class="w-full max-w-7xl flex flex-col lg:flex-row space-x-0 lg:space-x-6">
    <div class="w-full lg:w-7/10 flex flex-col items-center">
      <p id="step-description" class="text-sm text-gray-700 h-16 mb-2 font-semibold w-full text-left pl-2">Adjust
        settings and click 'Next Step'.</p>
      <div class="w-full flex justify-center border border-gray-200 rounded-lg shadow-md bg-white p-2">
        <canvas id="drawingCanvas" width="850" height="450"></canvas>
      </div>
      <div class="mt-4 flex justify-center space-x-4 w-full">
        <button id="prev-btn" class="step-button bg-gray-300 text-gray-800 p-3 rounded-lg font-medium" disabled>Previous
          Step</button>
        <button id="next-btn"
          class="step-button bg-blue-600 hover:bg-blue-700 text-white p-3 rounded-lg font-medium">Next Step</button>
      </div>
    </div>

    <div class="w-full lg:w-3/10 p-6 bg-white border border-gray-200 rounded-lg shadow-md mt-6 lg:mt-0">
      <h2 class="text-lg font-semibold text-gray-800 mb-4">Geometry Settings</h2>
      <div class="input-group">
        <label for="numSides">Number of Sides (N):</label>
        <input type="number" id="numSides" value="4" min="3" max="15">
      </div>
      <div class="input-group">
        <label for="sideLength">Side Length (mm):</label>
        <input type="number" id="sideLength" value="30" min="10" max="60">
      </div>
      <button id="reset-btn" class="bg-red-500 hover:bg-red-600 text-white p-2 rounded-lg font-medium w-full mt-4">Reset
        Drawing</button>
    </div>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const canvas = document.getElementById('drawingCanvas');
      const ctx = canvas.getContext('2d');
      const prevBtn = document.getElementById('prev-btn');
      const nextBtn = document.getElementById('next-btn');
      const resetBtn = document.getElementById('reset-btn');
      const stepDesc = document.getElementById('step-description');

      let currentStep = 0;
      let poly = { vertices: [], arcs: [], n: 4, side: 30 };
      const SEGMENTS = 100;

      function initGeometry() {
        const n = parseInt(document.getElementById('numSides').value);
        const side = parseFloat(document.getElementById('sideLength').value);
        const vertices = [];
        const R = side / (2 * Math.sin(Math.PI / n));

        for (let i = 0; i < n; i++) {
          const angle = (Math.PI / 2) - (i * 2 * Math.PI / n);
          vertices.push({ x: R * Math.cos(angle), y: -R * Math.sin(angle) });
        }

        const arcs = [];
        let lastPt = vertices[0];
        for (let i = 0; i < n; i++) {
          const pivot = vertices[(i + 1) % n];
          const radius = (i + 1) * side;
          const startAngle = Math.atan2(lastPt.y - pivot.y, lastPt.x - pivot.x);
          const sweepAngle = (2 * Math.PI) / n;

          const arcPoints = [];
          for (let j = 0; j <= SEGMENTS; j++) {
            const angle = startAngle + (sweepAngle * (j / SEGMENTS));
            const pt = { x: pivot.x + radius * Math.cos(angle), y: pivot.y + radius * Math.sin(angle) };
            arcPoints.push(pt);
            if (j === SEGMENTS) lastPt = pt;
          }
          arcs.push(arcPoints);
        }

        const targetIdx = Math.max(0, n - 2);
        const M = arcs[targetIdx][Math.floor(SEGMENTS * 0.5)];
        const M_pivot = vertices[(targetIdx + 1) % n];

        poly = { vertices, arcs, n, side, M, M_pivot };
      }

      function drawTextWithHalo(text, x, y, color) {
        ctx.save();
        ctx.font = `${14 / 2.0}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.lineWidth = 4 / 2.0;
        ctx.strokeStyle = 'white';
        ctx.strokeText(text, x, y);
        ctx.fillStyle = color;
        ctx.fillText(text, x, y);
        ctx.restore();
      }

      function draw() {
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const scale = 2.0;
        ctx.translate(canvas.width / 2, canvas.height / 2);
        ctx.scale(scale, scale);

        const { vertices, arcs, n, M, M_pivot, side } = poly;
        const MAX_ARC_STEP = n + n;

        // 1. Continuous Tangent Lines
        if (currentStep >= n) {
          ctx.strokeStyle = '#e2e8f0';
          ctx.lineWidth = 1 / scale;
          vertices.forEach((v, i) => {
            const next = vertices[(i + 1) % n];
            const dx = v.x - next.x, dy = v.y - next.y;
            ctx.beginPath();
            ctx.moveTo(next.x, next.y);
            ctx.lineTo(next.x + dx * 10, next.y + dy * 10);
            ctx.stroke();
          });
        }

        // 2. Polygon & Vertex Namings
        ctx.strokeStyle = '#1e40af';
        ctx.lineWidth = 2.5 / scale;
        ctx.beginPath();
        vertices.forEach((v, i) => {
          if (i <= currentStep) {
            if (i === 0) ctx.moveTo(v.x, v.y);
            else ctx.lineTo(v.x, v.y);

            // Offset labeling away from center
            const labelX = v.x * 1.2;
            const labelY = v.y * 1.2;
            drawTextWithHalo(`P${i + 1}`, labelX, labelY, '#1e40af');
          }
        });
        if (currentStep >= n - 1) ctx.closePath();
        ctx.stroke();

        // 3. Involute Arcs & Endpoints
        if (currentStep >= n) {
          ctx.strokeStyle = '#dc2626';
          ctx.lineWidth = 3 / scale;
          ctx.beginPath();
          ctx.moveTo(vertices[0].x, vertices[0].y);
          const activeArcs = Math.min(n, currentStep - n);
          for (let i = 0; i < activeArcs; i++) {
            arcs[i].forEach(p => ctx.lineTo(p.x, p.y));
            const endPt = arcs[i][SEGMENTS];
            // Offset arc label
            drawTextWithHalo(`C${i + 1}`, endPt.x + 15 / scale, endPt.y + 15 / scale, '#dc2626');
          }
          ctx.stroke();
        }

        // 4. Tangent & Normal Namings
        if (currentStep > MAX_ARC_STEP) {
          const tnStep = currentStep - MAX_ARC_STEP;
          const ext = n * side * 0.6;
          const dx = M.x - M_pivot.x, dy = M.y - M_pivot.y;
          const len = Math.sqrt(dx * dx + dy * dy);
          const ux = dx / len, uy = dy / len;

          if (tnStep >= 1) { // Point M
            ctx.fillStyle = '#f59e0b';
            ctx.beginPath(); ctx.arc(M.x, M.y, 4 / scale, 0, Math.PI * 2); ctx.fill();
            drawTextWithHalo("M", M.x, M.y - 12 / scale, '#b45309');
          }
          if (tnStep >= 2) { // Normal
            ctx.strokeStyle = '#059669';
            ctx.lineWidth = 2 / scale;
            ctx.beginPath();
            ctx.moveTo(M_pivot.x, M_pivot.y);
            ctx.lineTo(M_pivot.x + ux * (len + ext), M_pivot.y + uy * (len + ext));
            ctx.stroke();
            drawTextWithHalo("N-N'", M_pivot.x + ux * (len + ext + 10 / scale), M_pivot.y + uy * (len + ext + 10 / scale), '#059669');
          }
          if (tnStep >= 3) { // Tangent
            ctx.strokeStyle = '#ef4444';
            ctx.lineWidth = 2 / scale;
            ctx.beginPath();
            ctx.moveTo(M.x - uy * ext, M.y + ux * ext);
            ctx.lineTo(M.x + uy * ext, M.y - ux * ext);
            ctx.stroke();
            drawTextWithHalo("T-T'", M.x + uy * (ext + 10 / scale), M.y - ux * (ext + 10 / scale), '#ef4444');
          }
        }

        updateDescription();
        prevBtn.disabled = currentStep === 0;
        nextBtn.disabled = currentStep >= (n + n + 3);
      }

      function updateDescription() {
        const { n } = poly;
        if (currentStep < n) stepDesc.textContent = `Drawing polygon side P${currentStep}P${currentStep + 1}.`;
        else if (currentStep < n + n) stepDesc.textContent = `Constructing involute arc segment C${currentStep - n + 1}.`;
        else if (currentStep === n + n + 1) stepDesc.textContent = `Mark point M on the curve.`;
        else if (currentStep === n + n + 2) stepDesc.innerHTML = `Draw the <span class="normal-color">Normal</span> line.`;
        else if (currentStep === n + n + 3) stepDesc.innerHTML = `Draw the <span class="tangent-color">Tangent</span> line.`;
      }

      nextBtn.addEventListener('click', () => { currentStep++; draw(); });
      prevBtn.addEventListener('click', () => { currentStep--; draw(); });
      resetBtn.addEventListener('click', () => { currentStep = 0; initGeometry(); draw(); });

      initGeometry();
      draw();
    });
  </script>
</body>

</html>